
Java Fundamentals – Quick Reference for Demo

0. Opening Hook / Warmup (5 min)
--------------------------------
Story/Hook:
- Ask: "What’s the funniest or weirdest error message you’ve seen?"
- Show a tiny crash demo:
  int[] nums = {1, 2, 3};
  System.out.println(nums[5]); // ArrayIndexOutOfBoundsException
- Say: "This is an Exception — something went wrong. Today, we’ll see how to handle errors, manage data, and define strict rules in Java."

1. Exceptions – Handling Problems Gracefully (15 min)
-----------------------------------------------------
Pointers to say/demo:
- Definition: Events that disrupt normal flow.
- Error vs Exception:
  - Exception → program-level, recoverable
  - Error → JVM-level, not recoverable
- Types:
  - Checked → must handle/declare (IOException)
  - Unchecked → programming bugs (NullPointerException)
- Handling: try, catch, finally
- Throwing: Custom exceptions for business rules
- Best Practices: Only catch what you can fix; log exceptions

Demo reminder:
try {
    int result = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Division by zero not allowed.");
} finally {
    System.out.println("Cleanup runs always.");
}

Mini quiz questions:
1. Difference between Error and Exception?
2. Example of checked vs unchecked exception?
3. Purpose of finally block?

Transition to Collections:
- "Exceptions stop the program from crashing. But what happens when everything goes right and we need to handle lots of data?"

2. Collections Basics – Managing Data Flexibly (25 min)
------------------------------------------------------
Pointers to say/demo:
- Why collections: Arrays = fixed-size; collections = dynamic
- Main interfaces:
  - List → ordered, duplicates allowed
  - Set → unique elements only
  - Map → key-value pairs
- Analogies: List = shopping list; Set = basket of unique fruits; Map = dictionary
- Implementations: ArrayList, LinkedList, HashSet, TreeSet, HashMap, TreeMap
- Iteration: for-each, iterator, streams
- Best practice: Program to the interface, not implementation

Demo reminder:
List<String> names = new ArrayList<>();
names.add("Alice"); names.add("Bob"); names.add("Alice");
System.out.println(names); // duplicates allowed

Set<String> unique = new HashSet<>(names);
System.out.println(unique); // no duplicates

Map<String,Integer> scores = new HashMap<>();
scores.put("Alice", 90);
scores.put("Alice", 95); // overwrite
System.out.println(scores);

Mini quiz questions:
1. Collection for ordered items with duplicates? → List
2. Difference between HashSet and HashMap?
3. Why program to interface, not implementation?

Transition to Enums:
- "Collections can store any amount of data, but sometimes we only want a fixed set of values. For example, a package status can only be NEW, IN_TRANSIT, or DELIVERED. Strings could cause typos — how can we fix this?"

3. Enums – Defining Strict Categories (15 min)
-----------------------------------------------
Pointers to say/demo:
- Definition: Special class for fixed constants
- Why: Avoid magic numbers/strings, type-safe, readable
- Use cases: Directions, days, order statuses, error codes
- Features: Can use in switch; can add fields & methods; values() allows iteration

Demo reminder:
enum Direction { NORTH, SOUTH, EAST, WEST }
Direction dir = Direction.NORTH;

switch(dir) {
    case NORTH: System.out.println("Going up!"); break;
    case SOUTH: System.out.println("Going down!"); break;
}

for(Direction d : Direction.values()) {
    System.out.println(d);
}

Mini quiz questions:
1. Why use enums instead of String/int constants?
2. Can enums be used in a switch?
3. How to iterate all enum values?

4. Closing Activity – Quick Quiz/Game (2 min)
-----------------------------------------------
"Exception, Collection, or Enum?"
1. try { int x = 10/0; } catch(...) { ... } → Exceptions
2. List<String> names = new ArrayList<>(); → Collections
3. enum Direction {NORTH, SOUTH} → Enum
4. Program crashes with OutOfMemoryError → Error
5. Store unique student IDs → Set

Recap Line:
"Exceptions handle problems, Collections manage data, Enums define strict rules. Together, they make our Java programs reliable, flexible, and readable."

5. Transitions Summary
----------------------
1. Warmup → Exceptions: Show crash → motivate handling errors
2. Exceptions → Collections: "Exceptions stop crashes. But when everything works, we need to store/manage data. Arrays have limits → Collections solve that."
3. Collections → Enums: "Collections handle any data. But sometimes, we only want fixed, limited options. Strings are risky → Enums give fixed constants safely."
4. Closing: Tie all three together as a journey: Problem → Data → Rules